import java.util.function.Consumer

// root gradle file by nekit508

allprojects { Project project ->
    project.plugins.apply("java")
    project.plugins.apply("idea")
    project.plugins.apply("maven-publish")

    version = "v1.0"
    group = "github.teamoct.fictional-octo-system"
}

wrapper {
    gradleVersion = "8.1.1"
}

sourceSets.main.java.srcDirs = []
sourceSets.main.resources.srcDirs = []

ext {
    cleanBuilds = {
        subprojects.each { Project p ->
            if (p.buildDir.exists()) {
                delete {
                    it.delete(p.buildDir.listFiles() - p.ext.child(p.buildDir, "generated"))
                }
            }
        }
    }

    localProperties = new Properties()
    if (new File("$rootProject.projectDir/local.properties").exists())
        localProperties.load(new FileInputStream(new File("$rootProject.projectDir/local.properties")))

    setIfHasProp = { String property, Consumer<Object> set ->
        if (localProperties.containsKey(property))
            set.accept(localProperties.get(property))
    }
}

subprojects { Project project ->
    project.sourceSets.main.java.srcDirs = [
            "src",
            "$project.buildDir/generated/sources/annotationProcessor/java/main",
    ]
    project.sourceSets.main.resources.srcDirs = [
            "res",
    ]

    project.ext {
        APArgs = []

        copyPaths = [
                "$rootProject.projectDir/artifacts",
        ]
        mindustryVersion = "v144"

        child = { File p, String c ->
            return new File(p, c)
        }

        writeProcessors = {
            var processorPath = child(project.sourceSets.main.resources.srcDirs.getAt(0), "META-INF/services/")
            processorPath.mkdirs()
            var processorFile = child(processorPath, ("javax.annotation.processing.Processor"))
            var text = new StringBuilder()
            var srcFiles = project.sourceSets.main.java.srcDirs.getAt(0)
            srcFiles.eachFileRecurse(groovy.io.FileType.FILES){ file ->
                if(file.name.endsWith(".java") && ((file.text.contains(" extends AbstractProcessor")
                        && !file.text.contains("abstract class")))){
                    text.append(file.path.substring(srcFiles.path.length() + 1)).append("\n")
                }
            }
            processorFile.text = text.toString().replace(".java", "").replace("/", ".").replace("\\", ".")
        }
    }

    project.repositories {
        mavenCentral()
        maven { url "https://www.jitpack.io" }
    }

    project.tasks.withType(JavaCompile).configureEach {
        rootProject.ext.setIfHasProp("org.gradle.java.home", v -> options.forkOptions.executable = v)
        options.encoding = "UTF-8"
        sourceCompatibility = JavaVersion.VERSION_16
        targetCompatibility = JavaVersion.VERSION_16
        var finalAPArgs = []
        APArgs.each { String str ->
            if (!str.contains("-A"))
                finalAPArgs.add("-A" + str)
        }
        options.compilerArgs += finalAPArgs + "-AProjectName=$project.name"
    }

    project.tasks.create("cjar") {
        dependsOn project.tasks.jar
        doLast {
            rootProject.ext.cleanBuilds()
        }
    }

    project.tasks.jar {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        from {
            configurations.runtimeClasspath.collect { File file ->
                file.isDirectory() ? file : zipTree(file)
            }
        }
        doLast {
            copy {
                from {
                    archiveFile.get()
                }
                copyPaths.each { p ->
                    into(p)
                }
            }
        }
    }

    java {
        withSourcesJar()
        withJavadocJar()
    }

    publishing {
        publications {
            maven(MavenPublication) {
                groupId project.group
                artifactId project.name
                version project.version
                from components.java
            }
        }
    }
}

task publishProj {
    doLast {
        publishToMavenLocal
    }
}

task deploy {
    dependsOn subprojects.stream().<Task>map(p -> p.tasks.jar).toArray()
    doLast {
        rootProject.ext.cleanBuilds()
    }
    finalizedBy rootProject.tasks.publishProj
}
