import arc.files.Fi

import java.util.function.Consumer

static String getVersion(String dependence) {
    return dependence.substring(dependence.lastIndexOf(":")+1)
}

// attach Arc to build scripts
buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url "https://www.jitpack.io" }
        maven { url "https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository" }
    }

    dependencies {
        classpath "com.github.Anuken.Arc:arc-core:v146"
    }
}

// configure all projects
allprojects.each { Project project ->
    // attach repositories
    project.repositories {
        mavenCentral()
        mavenLocal()
        maven { url "https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository" }
        maven { url "https://www.jitpack.io" }
    }

    // apply plugins
    project.plugins.apply("java")
    project.plugins.apply("idea")
    project.plugins.apply("maven-publish")

    // set version and group
    project.version = properties.get("version")
    project.group = properties.get("group")
}

// no source code for root project
sourceSets.main.java.srcDirs = []
sourceSets.main.resources.srcDirs = []

ext {
    // load configs
    copyProperties = new Properties()
    if (rootProject.file("copy.properties").exists())
        copyProperties.load(new FileInputStream(rootProject.file("copy.properties")))

    localProperties = new Properties()
    if (new File("$rootProject.projectDir/local.properties").exists())
        localProperties.load(new FileInputStream(new File("$rootProject.projectDir/local.properties")))

    // setup annotation processors properties (global)
    var GAPAProps = new Fi(rootProject.file("APA.properties")) // global (for every projects)
    GAPArgs = []
    if (GAPAProps.exists()) {
        GAPArgs += Arrays.stream(GAPAProps.readString().replaceAll("\n", "").replaceAll("\r", "").split(";")).toList()
    }

    // parse dependencies
    dependenciesI = new HashMap<Project, String>()
    dependenciesC = new HashMap<Project, String>()
    dependenciesA = new HashMap<Project, String>()
    dependenciesList = new HashMap<String, String>()
    dependenciesProperties = new Properties()
    dependenciesProperties.load(new InputStreamReader(new FileInputStream(
            new File("$rootProject.projectDir/dependencies.properties"))))
    dependenciesProperties.forEach((k, v) -> {
        if (k.length() > 2) {
            switch (k.substring(k.length()-2)) {
                case "-C":
                    dependenciesC.put(project(k.substring(0, k.length()-2)), v)
                    break
                case "-I":
                    dependenciesI.put(project(k.substring(0, k.length()-2)), v)
                    break
                case "-A":
                    dependenciesA.put(project(k.substring(0, k.length()-2)), v)
                    break
                default:
                    dependenciesList.put(k, v)
            }
        } else {
            dependenciesList.put(k, v)
        }
    })

    // calls set if localProperties contains property
    setIfHasProp = { String property, Consumer<Object> set ->
        if (localProperties.containsKey(property))
            set.accept(localProperties.get(property))
    }

    // executes command
    doExec = { String cmd ->
        C.get()
        var proc = cmd.execute(null, rootProject.projectDir)
        proc.waitForProcessOutput(System.out, System.err)
    }

    // returns output jar name for specified project
    getOutputJar = {Project p ->
        return "${rootProject.name}-${p.name}-${p.version}.jar"
    }

    // returns child of the file
    child = { File p, String c ->
        return new File(p, c)
    }
}

// deletes build dirs in the subprojects
task cleanBuilds(type: Delete) {
    doLast {
        subprojects.each { Project p ->
            if (p.buildDir.exists()) {
                delete(p.buildDir)
            }
        }
    }
}

// configure every subproject
subprojects.each { Project project ->
    // Anuke
    project.configurations.all {
        resolutionStrategy.eachDependency { details ->
            if(details.requested.group == "com.github.Anuken.Arc"){
                String version = ""
                if (rootProject.ext.dependenciesC.containsKey(project))
                    rootProject.ext.dependenciesC.get(project).split(";").each { String dep ->
                        if (dep.contains("com.github.Anuken.Arc"))
                            version = getVersion(dep)
                    }
                if (rootProject.ext.dependenciesI.containsKey(project))
                    rootProject.ext.dependenciesI.get(project).split(";").each { String dep ->
                        if (dep.contains("com.github.Anuken.Arc"))
                            version = getVersion(dep)
                    }
                if (rootProject.ext.dependenciesA.containsKey(project))
                    rootProject.ext.dependenciesA.get(project).split(";").each { String dep ->
                        if (dep.contains("com.github.Anuken.Arc"))
                            version = getVersion(dep)
                    }

                if (version != "")
                    details.useVersion version
            }
        }
    }

    // setup sourcesets
    // src - java sources
    // gen - generated java sources
    // res - resources (e.g. assets)
    project.sourceSets.main.java.srcDirs = [
            "src", "gen"
    ]
    project.sourceSets.main.resources.srcDirs = [
            "res",
    ]

    project.ext {
        // setup annotation processors properties (local)
        APArgs = ["ProjectName=${project.name}"]
        var src = "ProjectSrc=", res = "ProjectRes="
        project.sourceSets.main.java.srcDirs.each { var str ->
            src += str.toString() + ";"
        }
        project.sourceSets.main.resources.srcDirs.each { var str ->
            res += str.toString() + ";"
        }
        APArgs.add(src.substring(0, src.length()-1))
        APArgs.add(res.substring(0, res.length()-1))
        var APAProps = new Fi(project.file("APA.properties")) // local (only for this project)
        if (APAProps.exists()) {
            APArgs += Arrays.stream(APAProps.readString().replaceAll("\n", "").replaceAll("\r", "").split(";")).toList()
        }
        APArgs += rootProject.ext.GAPArgs

        // load paths where output jar will be copied
        copyPaths = []
        if (rootProject.ext.copyProperties.containsKey(project.name))
            copyPaths += Arrays.stream(rootProject.ext.copyProperties.get(project.name).split(";")).toList()

        // writes javax.annotation.processing.Processor file
        writeProcessors = {
            var processorPath = rootProject.ext.child(project.sourceSets.main.resources.srcDirs.getAt(0), "META-INF/services/")
            processorPath.mkdirs()
            var processorFile = rootProject.ext.child(processorPath, ("javax.annotation.processing.Processor"))
            var text = new StringBuilder()
            var srcFiles = project.sourceSets.main.java.srcDirs.getAt(0)
            if (srcFiles.exists()) {
                srcFiles.eachFileRecurse(groovy.io.FileType.FILES) { file ->
                    if (file.name.endsWith(".java") && file.text.contains("@AnnotationProcessor")) {
                        text.append(file.path.substring(srcFiles.path.length() + 1)).append("\n")
                    }
                }
            }
            processorFile.text = text.toString().replace(".java", "").replace("/", ".").replace("\\", ".")
        }
    }

    project.dependencies {
        // setup parsed dependencies
        if (rootProject.ext.dependenciesC.containsKey(project))
            rootProject.ext.dependenciesC.get(project).split(";").each { String dep ->
                compileOnly rootProject.ext.dependenciesList.get(dep)
            }
        if (rootProject.ext.dependenciesI.containsKey(project))
            rootProject.ext.dependenciesI.get(project).split(";").each { String dep ->
                implementation rootProject.ext.dependenciesList.get(dep)
            }
        if (rootProject.ext.dependenciesA.containsKey(project))
            rootProject.ext.dependenciesA.get(project).split(";").each { String dep ->
                annotationProcessor rootProject.ext.dependenciesList.get(dep)
            }

        // needs for translate mod to 64 bytecode
        annotationProcessor "com.github.Anuken:jabel:93fde537c7"
    }

    project.tasks.withType(JavaCompile) {
        // preprocess annotation processors properties
        var finalAPArgs = []
        project.ext.APArgs.each { String str ->
            if (!str.contains("-A"))
                finalAPArgs.add("-A" + str)
        }
        options.compilerArgs.addAll(finalAPArgs)

        // setup compile options
        options.encoding = "UTF-8"
        options.compilerArgs.addAll(["-Xlint:none"])
        options.compilerArgs.addAll(['--release', '8'])
        options.generatedSourceOutputDirectory.set(project.file("gen"))
        options.forkOptions.jvmArgs.addAll([
                "--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
                "--add-opens=java.base/sun.reflect.annotation=ALL-UNNAMED"
        ])

        // if you want to specify jvm path
        rootProject.ext.setIfHasProp("org.gradle.java.home", v -> options.forkOptions.executable = v)

        // project should be complied in 64 bytecode version
        targetCompatibility = 8
        sourceCompatibility = JavaVersion.VERSION_16

        doFirst {
            // clear previously generated sources
            delete options.generatedSourceOutputDirectory.get().asFile.listFiles()
        }
    }

    // copy output jar
    project.tasks.create("copyJar") {
        doLast {
            project.ext.copyPaths.each { p ->
                copy {
                    from project.tasks.jar
                    into p
                }
            }
        }
    }

    project.tasks.jar {
        archiveFileName = rootProject.ext.getOutputJar(project)

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        from {
            project.configurations.runtimeClasspath.collect { File file ->
                file.isDirectory() ? file : zipTree(file)
            }
        }

        finalizedBy project.tasks.copyJar
    }

    // for jitpack publishing
    project.java {
        withSourcesJar()
        withJavadocJar()
    }

    project.publishing {
        publications {
            maven(MavenPublication) {
                groupId "github.${project.group.replaceAll("/", ".")}"
                artifactId project.name
                version project.version
                from components.java
            }
        }
    }
}

// builds jar with android and desktop sources
task buildRelease(type: Jar) {
    dependsOn subprojects.stream().<Task>map(p -> p.tasks.jar).toArray()

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from {
        zipTree(project(":android").tasks.jar.archiveFile.get())
        zipTree(project(":desktop").tasks.jar.archiveFile.get())
    }

    doLast {
        // copy it to specified directories
        def copyPaths = [
                "$rootProject.projectDir/artifacts",
        ]
        if (rootProject.ext.copyProperties.containsKey("release"))
            copyPaths += Arrays.stream(rootProject.ext.copyProperties.get("release").split(";")).toList()

        copyPaths.each { p ->
            copy {
                from {
                    project.tasks.jar.archiveFile.get()
                }
                into(p)
            }
        }
    }

    finalizedBy rootProject.tasks.cleanBuilds
}

// for github actions
task workflowBuild {
    dependsOn buildRelease
}
